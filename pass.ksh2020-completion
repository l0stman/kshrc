# -*-sh-*-
# completion file for ksh2020, based on the one for bash.

# Copyright (C) 2012 - 2014 Jason A. Donenfeld <Jason@zx2c4.com> and
# Brian Mattern <rephorm@rephorm.com>. All Rights Reserved.
# This file is licensed under the GPLv2+. Please see COPYING for more
# information.

function _pass_complete_entries
{
    typeset cur="${COMP_WORDS[COMP_CWORD]}"
    typeset prefix="${PASSWORD_STORE_DIR:-$HOME/.password-store/}"
    prefix="${prefix%/}/"
    typeset suffix=".gpg"
    typeset autoexpand=${1:-0}

    typeset ifs=${IFS}
    export IFS=$'\n'
    typeset items
    typeset path="${prefix}${cur}"

    if [[ -d "${path}" ]]; then
        items=($(cd "${path}"; compgen -P "${path}" -fd))
    else
        typeset d="${path%/*}"
        items=($(cd "${d}"; compgen -P "${d}/" -fd "${cur##*/}"))
    fi
    
    # Remember the value of the first item, to see if it is a directory. If
    # it is a directory, then don't add a space to the completion
    typeset firstitem=""
    # Use counter, can't use ${#items[@]} as we skip hidden directories
    typeset i=0 item

    for item in ${items[@]}; do
	# if there is a unique match, and it is a directory with one entry
	# autocomplete the subentry as well (recursively)
	if [[ ${#items[@]} -eq 1 && $autoexpand -eq 1 ]]; then
	    while [[ -d $item ]]; do
		typeset subitems=($(cd ${item}; compgen -P "${item}/" -fd))
		if [[ ${#subitems[@]} -eq 1 ]]; then
		    item="${subitems[0]}"
		else
		    break
		fi
	    done
	fi

	# append / to directories
	[[ -d $item ]] && item="$item/"

	item="${item%$suffix}"
	COMPREPLY+=("${item#$prefix}")
	if [[ $i -eq 0 ]]; then
	    firstitem=$item
	fi
	let i+=1
    done
    IFS=${ifs}

    # The only time we want to add a space to the end is if there is only
    # one match, and it is not a directory
    if [[ $i -gt 1 || ( $i -eq 1 && -d $firstitem ) ]]; then
	complete -a setopt nospace
    fi
}

function _pass_complete_folders
{
    typeset cur="${COMP_WORDS[COMP_CWORD]}"
    typeset prefix="${PASSWORD_STORE_DIR:-$HOME/.password-store/}"
    prefix="${prefix%/}/"

    typeset w=$(basename "${cur}")
    typeset d=${prefix}${cur%$w}
    typeset ifs=${IFS}
    export IFS=$'\n'
    typeset items=($(cd $d; compgen -P $d -d $w))
    for item in ${items[@]}; do
	COMPREPLY+=("${item#$prefix}/")
    done
    IFS=${ifs}
}

function _pass_complete_keys
{
    typeset cur="${COMP_WORDS[COMP_CWORD]}"
    typeset GPG="gpg"
    which gpg2 >/dev/null 2>&1 && GPG="gpg2"

    # Extract names and email addresses from gpg --list-keys
    typeset keys="$($GPG --list-secret-keys --with-colons | cut -d : -f 10 | sort -u | sed '/^$/d')"
    typeset ifs=${IFS}
    IFS=$'\n' COMPREPLY+=($(compgen -W "${keys}" -- ${cur}))
    IFS=${ifs}
}

function _pass
{
    set -A COMPREPLY
    typeset cur="${COMP_WORDS[COMP_CWORD]}"
    typeset commands="init ls find grep show insert generate edit rm mv cp git help version ${PASSWORD_STORE_EXTENSION_COMMANDS[*]}"
    if [[ $COMP_CWORD -gt 1 ]]; then
	typeset lastarg="${COMP_WORDS[$COMP_CWORD-1]}"
	case "${COMP_WORDS[1]}" in
	    init)
		if [[ $lastarg == "-p" || $lastarg == "--path" ]]; then
		    _pass_complete_folders
                    complete -a setopt nospace
		else
		    COMPREPLY+=($(compgen -W "-p --path" -- ${cur}))
		    _pass_complete_keys
		fi
		;;
	    ls|list|edit)
		_pass_complete_entries
		;;
	    show|-*)
		COMPREPLY+=($(compgen -W "-c --clip" -- ${cur}))
		_pass_complete_entries 1
		;;
	    insert)
		COMPREPLY+=($(compgen -W "-e --echo -m --multiline -f --force" -- ${cur}))
		_pass_complete_entries
		;;
	    generate)
		COMPREPLY+=($(compgen -W "-n --no-symbols -c --clip -f --force -i --in-place" -- ${cur}))
		_pass_complete_entries
		;;
	    cp|copy|mv|rename)
		COMPREPLY+=($(compgen -W "-f --force" -- ${cur}))
		_pass_complete_entries
		;;
	    rm|remove|delete)
		COMPREPLY+=($(compgen -W "-r --recursive -f --force" -- ${cur}))
		_pass_complete_entries
		;;
	    git)
		COMPREPLY+=($(compgen -W "init push pull config log reflog rebase" -- ${cur}))
		;;
	esac

	# To add completion for an extension command define a function like this:
	# __password_store_extension_complete_<COMMAND>() {
	#     COMPREPLY+=($(compgen -W "-o --option" -- ${cur}))
	#     _pass_complete_entries 1
	# }
	#
	# and add the command to the $PASSWORD_STORE_EXTENSION_COMMANDS array
	if [[ " ${PASSWORD_STORE_EXTENSION_COMMANDS[*]} " == *" ${COMP_WORDS[1]} "* ]] && type "__password_store_extension_complete_${COMP_WORDS[1]}" > /dev/null 2>&1; then
	    "__password_store_extension_complete_${COMP_WORDS[1]}"
	fi
    else
	COMPREPLY+=($(compgen -W "${commands}" -- ${cur}))
	_pass_complete_entries 1
    fi
}

if builtin complete >/dev/null 2>&1; then
    complete -o filenames -F _pass pass
fi
